{"file_contents":{"README.md":{"content":"# Sistemas Olivium - Painel de Monitoramento de Rede\n\n## üìã Vis√£o Geral\n\nO Sistema de Monitoramento de Rede da Sistemas Olivium √© uma solu√ß√£o profissional e moderna para monitoramento em tempo real de dispositivos de rede. O sistema oferece uma interface web elegante e responsiva, com capacidade de monitorar centenas de m√°quinas simultaneamente atrav√©s de verifica√ß√µes ICMP ping e TCP.\n\n### ‚ú® Principais Recursos\n\n- **Monitoramento em Tempo Real**: Verifica√ß√£o autom√°tica do status online/offline de todas as m√°quinas\n- **Interface Moderna**: Dashboard profissional com modo escuro/claro altern√°vel\n- **Exporta√ß√£o de Relat√≥rios**: Gera√ß√£o de relat√≥rios PDF profissionais com header e footer personalizados\n- **Hist√≥rico Completo**: Rastreamento de mudan√ßas de status com timestamps em hor√°rio de Bras√≠lia\n- **Alertas Inteligentes**: Notifica√ß√µes para m√°quinas offline por mais de 5 minutos\n- **Performance Otimizada**: Sistema otimizado para lidar com dezenas de m√°quinas eficientemente\n- **Busca e Filtros**: Pesquisa por nome ou IP com filtros de status\n- **Responsivo**: Interface adapt√°vel para diferentes tamanhos de tela\n\n## üöÄ Instala√ß√£o\n\n### Pr√©-requisitos\n\n- Python 3.11 ou superior\n- Sistema operacional: Windows ou Linux\n- Acesso de rede para as m√°quinas que ser√£o monitoradas\n\n### Passo 1: Clonar ou baixar o projeto\n\n```bash\n# Se usando git\ngit clone [url-do-repositorio]\ncd sistema-monitoramento-rede\n\n# Ou simplesmente extrair os arquivos para uma pasta\n```\n\n### Passo 2: Instalar depend√™ncias\n\nO projeto usa uv para gerenciamento de depend√™ncias (recomendado) ou pip tradicional:\n\n**Usando uv (recomendado):**\n```bash\n# O uv ser√° instalado automaticamente se necess√°rio\nuv add flask sqlalchemy pytz reportlab openpyxl pandas\n```\n\n**Usando pip:**\n```bash\npip install flask sqlalchemy pytz reportlab openpyxl pandas\n```\n\n### Passo 3: Configurar o arquivo de m√°quinas\n\nEdite o arquivo `machines.csv` com suas m√°quinas:\n\n```csv\nNome,IP\nSERVIDOR-01,192.168.0.10\nFINANCEIRO-PC,192.168.0.15\nRECEPCAO-01,192.168.0.20\nCME-04,192.168.0.25\n```\n\n**Formato do arquivo:**\n- Primeira linha deve ser o cabe√ßalho: `Nome,IP`\n- Cada linha seguinte deve ter: `Nome da M√°quina,Endere√ßo IP`\n- IPs inv√°lidos (com \"/\" ou \"?\") ser√£o automaticamente ignorados\n- Linhas vazias s√£o ignoradas\n\n## ‚ñ∂Ô∏è Como Executar\n\n### Iniciar o sistema\n\n```bash\npython app.py\n```\n\n### Acessar o dashboard\n\nAbra seu navegador e acesse:\n```\nhttp://localhost:5000\n```\n\nO sistema estar√° dispon√≠vel imediatamente e come√ßar√° a monitorar as m√°quinas automaticamente.\n\n## üìä Funcionalidades Detalhadas\n\n### Dashboard Principal\n\nO dashboard moderno oferece:\n\n**üìà Estat√≠sticas em Tempo Real:**\n- Total de m√°quinas monitoradas\n- N√∫mero de m√°quinas online/offline\n- Lat√™ncia m√©dia da rede\n- √öltima atualiza√ß√£o\n\n**üîç Pesquisa e Filtros:**\n- Pesquisa por nome da m√°quina ou endere√ßo IP\n- Filtro por status (Online/Offline/Todos)\n- Resultados em tempo real\n\n**üìã Tabela de M√°quinas:**\n- Status visual com cores (verde=online, vermelho=offline)\n- Lat√™ncia em millisegundos\n- Data/hora da √∫ltima verifica√ß√£o\n- Hist√≥rico individual de cada m√°quina\n\n### ‚ö° Modo Escuro/Claro\n\n**Como usar:**\n1. Clique no √≠cone de lua/sol no canto superior direito\n2. A prefer√™ncia √© salva automaticamente no navegador\n3. O sistema detecta automaticamente a prefer√™ncia do sistema operacional\n\n### üìÑ Exporta√ß√£o de Relat√≥rios PDF\n\n**Como gerar:**\n1. Clique no bot√£o \"Exportar PDF\" no header\n2. O arquivo ser√° baixado automaticamente\n\n**Conte√∫do do relat√≥rio:**\n- Header profissional com logo \"Sistemas Olivium\"\n- Data e hora de gera√ß√£o\n- Resumo executivo com estat√≠sticas\n- Tabela completa de todas as m√°quinas\n- Footer com direitos autorais e ano atual\n- Styling profissional com cores modernas\n\n### üìà Hist√≥rico de M√°quinas\n\n**Como visualizar:**\n1. Na tabela principal, clique em \"Hist√≥rico\" na linha da m√°quina desejada\n2. Modal ser√° aberto com os √∫ltimos 50 registros de mudan√ßa de status\n3. Mostra timestamps precisos e lat√™ncia quando dispon√≠vel\n\n## ‚öôÔ∏è Configura√ß√£o Avan√ßada\n\n### Par√¢metros do Sistema\n\nNo arquivo `app.py`, voc√™ pode ajustar:\n\n```python\nCHECK_INTERVAL = 10          # Intervalo entre varreduras (segundos)\nPING_TIMEOUT_MS = 800        # Timeout do ping (millisegundos)\nMAX_WORKERS = 32             # N√∫mero m√°ximo de threads paralelas\nPORTAS_TCP_TESTE = [3389, 445, 80]  # Portas para teste TCP\nMAX_RETRIES = 2              # Tentativas de ping antes de considerar offline\n```\n\n### Algoritmo de Detec√ß√£o\n\nO sistema usa um algoritmo inteligente em duas etapas:\n\n1. **ICMP Ping**: Primeira tentativa usando ping tradicional\n2. **TCP Check**: Se ICMP falhar, testa portas comuns (RDP, SMB, HTTP)\n3. **M√∫ltiplas Tentativas**: At√© 2 tentativas antes de marcar como offline\n\n### Performance e Otimiza√ß√µes\n\n**Otimiza√ß√µes implementadas:**\n- Threading otimizado com pool de 32 workers\n- Cache inteligente de m√°quinas (5 minutos)\n- Timeout reduzido para melhor responsividade\n- Logging detalhado para monitoramento\n- Conex√µes de banco otimizadas\n- Filtros de IP inv√°lidos\n\n## üîß Solu√ß√£o de Problemas\n\n### Problema: M√°quinas n√£o aparecem\n\n**Solu√ß√£o:**\n1. Verifique o formato do arquivo `machines.csv`\n2. Certifique-se que n√£o h√° caracteres especiais nos IPs\n3. Verifique os logs no console para erros de carregamento\n\n### Problema: M√°quinas sempre offline\n\n**Poss√≠veis causas:**\n1. **Firewall**: M√°quinas podem estar bloqueando ping\n2. **Rede**: Problemas de conectividade de rede\n3. **IPs inv√°lidos**: Verifique se os IPs est√£o corretos\n\n**Solu√ß√£o:**\n1. Teste ping manual: `ping 192.168.0.10`\n2. Verifique se as portas TCP est√£o abertas\n3. Confirme que a m√°quina de monitoramento tem acesso √† rede\n\n### Problema: Sistema lento\n\n**Solu√ß√£o:**\n1. Reduza o n√∫mero de m√°quinas monitoradas\n2. Aumente o `CHECK_INTERVAL` para 15-30 segundos\n3. Reduza `MAX_WORKERS` se tiver limita√ß√µes de CPU\n\n### Problema: PDF n√£o exporta\n\n**Poss√≠veis causas:**\n1. Biblioteca reportlab n√£o instalada corretamente\n2. Permiss√µes de escrita no navegador\n\n**Solu√ß√£o:**\n```bash\n# Reinstalar depend√™ncias\npip install --force-reinstall reportlab\n# ou\nuv add reportlab\n```\n\n## üîß Manuten√ß√£o\n\n### Banco de Dados\n\nO sistema usa SQLite (`status.db`) para armazenar o hist√≥rico. Para limpeza:\n\n```bash\n# Backup do banco\ncp status.db status_backup.db\n\n# O banco √© automaticamente otimizado pelo sistema\n```\n\n### Logs\n\nOs logs s√£o exibidos no console. Para log permanente:\n\n```bash\npython app.py > monitoramento.log 2>&1\n```\n\n### Atualiza√ß√£o de M√°quinas\n\nPara adicionar/remover m√°quinas:\n1. Edite o arquivo `machines.csv`\n2. O sistema detectar√° automaticamente as mudan√ßas em at√© 5 minutos\n3. N√£o √© necess√°rio reiniciar o sistema\n\n## üì± Compatibilidade\n\n### Navegadores Suportados\n- Chrome 90+\n- Firefox 88+\n- Safari 14+\n- Edge 90+\n\n### Sistemas Operacionais\n- **Servidor**: Windows, Linux\n- **Cliente**: Qualquer sistema com navegador moderno\n\n### Dispositivos M√≥veis\n- Interface totalmente responsiva\n- Funciona em tablets e smartphones\n- Modo escuro/claro em todos os dispositivos\n\n## üö® Alertas e Notifica√ß√µes\n\n### Alertas Cr√≠ticos\n\nO sistema automaticamente identifica:\n- M√°quinas offline por mais de 5 minutos\n- Quantidade total de alertas cr√≠ticos\n- Dura√ß√£o do tempo offline\n\n**Como visualizar:**\n- Alertas aparecem automaticamente no dashboard\n- Se√ß√£o espec√≠fica com destaque visual\n- Atualiza√ß√£o em tempo real\n\n## üé® Personaliza√ß√£o Visual\n\n### Cores e Temas\n\n**Modo Claro:**\n- Background: Tons de branco e cinza claro\n- Acentos: Azul profissional (#1e40af)\n- Status: Verde (#059669) e vermelho (#dc2626)\n\n**Modo Escuro:**\n- Background: Tons de slate/cinza escuro\n- Texto: Branco e cinza claro\n- Mant√©m mesmos acentos para consist√™ncia\n\n### Header Fixo\n\n- O header \"Sistemas Olivium\" permanece vis√≠vel durante scroll\n- Gradiente profissional azul/roxo no √≠cone\n- Toggle de modo escuro/claro sempre acess√≠vel\n\n### Footer Profissional\n\n- Copyright din√¢mico com ano atual\n- Adapta automaticamente ao tema ativo\n- Posicionamento fixo na parte inferior\n\n## üìû Suporte\n\n### Para Problemas T√©cnicos\n\n1. **Verifique os logs** no console do sistema\n2. **Teste conectividade** manual com as m√°quinas\n3. **Confirme permiss√µes** de rede e firewall\n4. **Valide o arquivo** `machines.csv`\n\n### Contato\n\nPara suporte adicional, consulte a equipe de TI da Sistemas Olivium.\n\n---\n\n## üìù Changelog\n\n### Vers√£o 2.0 (Atual)\n- ‚ú® Interface completamente modernizada\n- üåô Modo escuro/claro\n- üìä Dashboard profissional\n- ‚ö° Performance otimizada\n- üìÑ PDF export aprimorado\n- üîß Backend otimizado com threading\n- üì± Design responsivo completo\n\n### Vers√£o 1.0\n- Monitoramento b√°sico de rede\n- Interface simples\n- Exporta√ß√£o CSV\n\n---\n\n**¬© 2025 Sistemas Olivium - Todos os direitos reservados**","size_bytes":8927},"app.py":{"content":"import csv\nimport os\nimport platform\nimport socket\nimport subprocess\nimport threading\nimport time\nimport queue\nimport logging\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\nfrom datetime import datetime, timedelta\nimport pytz\n\nfrom flask import Flask, jsonify, render_template, send_file, request\nfrom sqlalchemy import Column, DateTime, Integer, String, create_engine, func\nfrom sqlalchemy.orm import declarative_base, sessionmaker\nimport io\nfrom reportlab.lib.pagesizes import A4, landscape\nfrom reportlab.lib import colors\nfrom reportlab.lib.units import inch\nfrom reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle\nfrom reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer\n\n# ===================== CONFIGURA√á√ÉO =====================\n# Configura√ß√£o do fuso hor√°rio de Bras√≠lia\nBRASILIA_TZ = pytz.timezone('America/Sao_Paulo')\nDB_FILE = \"status.db\"\nMACHINES_FILE = \"machines.csv\"\nCHECK_INTERVAL = 10          # segundos entre varreduras\nPING_TIMEOUT_MS = 800        # Reduzido para melhor performance\nMAX_WORKERS = 32             # Otimizado para efici√™ncia\nNETWORK_RANGE = \"192.168.0.\"  # base para varredura (0-254)\nPORTAS_TCP_TESTE = [3389, 445, 80]\nMAX_RETRIES = 2              # Tentativas de ping\nCACHE_TIMEOUT = 300          # Cache timeout em segundos\n# ==================================================\n\napp = Flask(__name__, template_folder=\"templates\")\nBase = declarative_base()\n\nclass HostHistory(Base):\n    __tablename__ = \"history\"\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    name = Column(String)\n    ip = Column(String)\n    status = Column(String)\n    latency_ms = Column(Integer, nullable=True)\n    timestamp = Column(DateTime, default=lambda: datetime.now(BRASILIA_TZ))\n\n# Configura√ß√£o otimizada do banco\nengine = create_engine(\n    f\"sqlite:///{DB_FILE}\", \n    echo=False,\n    pool_pre_ping=True,\n    pool_recycle=3600,\n    connect_args={\"check_same_thread\": False}\n)\nBase.metadata.create_all(engine)\nSessionLocal = sessionmaker(bind=engine)\n\nstatus_cache = {}  # Agora usando hostname como chave\nmachines_cache = []  # Cache das m√°quinas carregadas\nlast_machines_load = 0  # Timestamp da √∫ltima carga\ndns_cache = {}  # Cache de resolu√ß√£o DNS: {hostname: {ip, resolved_at, ok, error}}\nmonitoring_stats = {\n    \"last_scan_duration\": 0,\n    \"successful_checks\": 0,\n    \"failed_checks\": 0,\n    \"total_scans\": 0\n}\n\n# Configura√ß√£o de logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# ----------------- Fun√ß√µes utilit√°rias -----------------\n\ndef resolve_hostname(hostname, timeout=3):\n    \"\"\"Resolve hostname para IP com cache TTL de 5 minutos - thread-safe\"\"\"\n    global dns_cache\n    now = time.time()\n    \n    # Verifica cache\n    if hostname in dns_cache:\n        cache_entry = dns_cache[hostname]\n        # Cache v√°lido por 5 minutos\n        if (now - cache_entry[\"resolved_at\"]) < 300:\n            if cache_entry[\"ok\"]:\n                return cache_entry[\"ip\"], None\n            else:\n                return None, cache_entry[\"error\"]\n    \n    try:\n        # Resolu√ß√£o DNS sem modificar timeout global - thread-safe\n        ip = socket.gethostbyname(hostname)\n        \n        # Armazena no cache\n        dns_cache[hostname] = {\n            \"ip\": ip,\n            \"resolved_at\": now,\n            \"ok\": True,\n            \"error\": None\n        }\n        \n        return ip, None\n        \n    except (socket.gaierror, Exception) as e:\n        error_msg = f\"DNS resolution failed: {str(e)}\"\n        \n        # Armazena erro no cache\n        dns_cache[hostname] = {\n            \"ip\": None,\n            \"resolved_at\": now,\n            \"ok\": False,\n            \"error\": error_msg\n        }\n        \n        return None, error_msg\n\ndef agora_brasilia():\n    \"\"\"Retorna a data/hora atual no fuso hor√°rio de Bras√≠lia\"\"\"\n    return datetime.now(BRASILIA_TZ)\n\ndef formatar_data_br(dt):\n    \"\"\"Formata uma data/hora para o padr√£o brasileiro\"\"\"\n    if dt is None:\n        return None\n    if dt.tzinfo is None:\n        # Se n√£o tem timezone, assume que √© UTC e converte para Bras√≠lia\n        dt = pytz.UTC.localize(dt).astimezone(BRASILIA_TZ)\n    elif dt.tzinfo != BRASILIA_TZ:\n        # Se tem timezone diferente, converte para Bras√≠lia\n        dt = dt.astimezone(BRASILIA_TZ)\n    return dt.strftime(\"%d/%m/%Y %H:%M:%S\")\n\ndef ping_icmp_target(target: str, retries=MAX_RETRIES):\n    \"\"\"Ping ICMP otimizado que aceita hostname ou IP com retry autom√°tico\"\"\"\n    is_windows = platform.system().lower() == \"windows\"\n    \n    for attempt in range(retries):\n        cmd = [\"ping\", \"-n\", \"1\", \"-w\", str(PING_TIMEOUT_MS), target] if is_windows else \\\n              [\"ping\", \"-c\", \"1\", \"-W\", str(int(PING_TIMEOUT_MS/1000) or 1), target]\n        \n        t0 = time.perf_counter()\n        try:\n            out = subprocess.run(\n                cmd, \n                capture_output=True, \n                text=True, \n                timeout=(PING_TIMEOUT_MS/1000 + 1),\n                creationflags=0x08000000 if is_windows else 0  # CREATE_NO_WINDOW flag for Windows\n            )\n            if out.returncode == 0:\n                latency = (time.perf_counter() - t0) * 1000.0\n                return True, round(latency, 1)\n        except (subprocess.TimeoutExpired, Exception) as e:\n            if attempt == retries - 1:\n                logger.debug(f\"Ping failed for {target}: {e}\")\n                continue\n    \n    return False, None\n\ndef tcp_ping(ip: str, port: int, timeout=0.3) -> bool:\n    \"\"\"TCP ping otimizado com timeout menor - sempre usa IP resolvido\"\"\"\n    if not ip:  # Se n√£o tem IP resolvido, falha\n        return False\n        \n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(timeout)\n        result = sock.connect_ex((ip, port))\n        sock.close()\n        return result == 0\n    except Exception:\n        return False\n\ndef checar_um_host(host: dict):\n    \"\"\"Verifica status de um host usando hostname como identidade principal\"\"\"\n    hostname = host[\"name\"]\n    ip_hint = host.get(\"ip\", None)  # IP opcional do CSV\n    \n    if not hostname:\n        return None\n    \n    try:\n        # Resolve o hostname para IP\n        resolved_ip, dns_error = resolve_hostname(hostname)\n        \n        online = False\n        latency = None\n        reason = None\n        \n        if resolved_ip:\n            # Primeiro tenta ICMP ping usando o hostname\n            online, latency = ping_icmp_target(hostname)\n            \n            # Se ICMP falhou, tenta TCP nas portas comuns usando o IP resolvido\n            if not online:\n                for port in PORTAS_TCP_TESTE:\n                    if tcp_ping(resolved_ip, port):\n                        online = True\n                        latency = None  # TCP ping n√£o mede lat√™ncia precisa\n                        break\n        else:\n            # Falha de DNS\n            reason = \"DNS_FAIL\"\n            logger.warning(f\"Falha de resolu√ß√£o DNS para {hostname}: {dns_error}\")\n\n        now = agora_brasilia()\n        existing = status_cache.get(hostname, {})\n        old_status = existing.get(\"status\")\n        new_status = \"Online\" if online else \"Offline\"\n\n        data = {\n            \"name\": hostname,\n            \"ip\": resolved_ip,  # IP atual resolvido ou None\n            \"status\": new_status,\n            \"last_checked\": now,\n            \"latency_ms\": latency,\n            \"reason\": reason,\n            \"ip_changed\": False  # Flag para indicar mudan√ßa de IP\n        }\n        \n        # Detecta mudan√ßa de IP e atualiza automaticamente\n        if existing and existing.get(\"ip\") and resolved_ip:\n            old_ip = existing.get(\"ip\")\n            if old_ip != resolved_ip:\n                logger.info(f\"IP ALTERADO para {hostname}: {old_ip} ‚Üí {resolved_ip}\")\n                data[\"ip_changed\"] = True\n                \n                # Grava mudan√ßa no hist√≥rico como evento especial\n                try:\n                    with SessionLocal() as db:\n                        db.add(HostHistory(\n                            name=hostname, \n                            ip=resolved_ip, \n                            status=f\"IP_CHANGED: {old_ip} ‚Üí {resolved_ip}\", \n                            latency_ms=None, \n                            timestamp=now\n                        ))\n                        db.commit()\n                        logger.info(f\"Registrada mudan√ßa de IP para {hostname} no hist√≥rico\")\n                except Exception as e:\n                    logger.error(f\"Erro ao registrar mudan√ßa de IP para {hostname}: {e}\")\n        \n        # Atualiza cache usando hostname como chave\n        status_cache[hostname] = data\n\n        # Se mudou de status, grava no banco\n        if old_status and old_status != new_status:\n            try:\n                with SessionLocal() as db:\n                    db.add(HostHistory(\n                        name=hostname, \n                        ip=resolved_ip or ip_hint or \"unknown\", \n                        status=new_status, \n                        latency_ms=latency, \n                        timestamp=now\n                    ))\n                    db.commit()\n            except Exception as e:\n                logger.error(f\"Erro ao salvar hist√≥rico para {hostname}: {e}\")\n        \n        # Atualiza estat√≠sticas\n        monitoring_stats[\"successful_checks\"] += 1\n        return data\n        \n    except Exception as e:\n        logger.error(f\"Erro ao verificar host {hostname}: {e}\")\n        monitoring_stats[\"failed_checks\"] += 1\n        return None\n\ndef carregar_maquinas():\n    \"\"\"Carrega m√°quinas do CSV com cache inteligente - agora aceita apenas hostname\"\"\"\n    global machines_cache, last_machines_load\n    \n    # Verifica se precisa recarregar (cache de 5 minutos)\n    now = time.time()\n    if machines_cache and (now - last_machines_load) < CACHE_TIMEOUT:\n        return machines_cache\n    \n    maquinas = []\n    if os.path.exists(MACHINES_FILE):\n        try:\n            with open(MACHINES_FILE, \"r\", encoding=\"utf-8\") as f:\n                reader = csv.reader(f)\n                next(reader, None)  # Pula o cabe√ßalho\n                for row_num, row in enumerate(reader, 2):  # Come√ßa do 2 por causa do header\n                    if len(row) >= 1:  # Agora s√≥ precisa do nome\n                        name = row[0].strip()\n                        ip_hint = row[1].strip() if len(row) >= 2 else None\n                        \n                        # S√≥ precisa do nome v√°lido\n                        if name:\n                            entry = {\"name\": name}\n                            # IP √© apenas uma dica opcional\n                            if ip_hint and ip_hint != \"?\" and \"/\" not in ip_hint:\n                                entry[\"ip\"] = ip_hint\n                            maquinas.append(entry)\n                        else:\n                            logger.warning(f\"Nome vazio na linha {row_num}\")\n            \n            logger.info(f\"Carregadas {len(maquinas)} m√°quinas do arquivo {MACHINES_FILE}\")\n            \n        except Exception as e:\n            logger.error(f\"Erro ao carregar m√°quinas: {e}\")\n    else:\n        logger.warning(f\"Arquivo {MACHINES_FILE} n√£o encontrado. Criando varredura autom√°tica.\")\n        # se n√£o existir CSV, tenta varrer rede (ping em range limitado)\n        for i in range(1, 51):  # Limita a varredura para performance\n            maquinas.append({\"name\": f\"Host-{i}\", \"ip\": f\"{NETWORK_RANGE}{i}\"})\n    \n    # Atualiza cache\n    machines_cache = maquinas\n    last_machines_load = now\n    \n    return maquinas\n\ndef worker_loop():\n    \"\"\"Loop principal de monitoramento otimizado\"\"\"\n    logger.info(\"Iniciando worker de monitoramento...\")\n    \n    while True:\n        try:\n            start_time = time.perf_counter()\n            maquinas = carregar_maquinas()\n            \n            if not maquinas:\n                logger.warning(\"Nenhuma m√°quina para monitorar\")\n                time.sleep(CHECK_INTERVAL)\n                continue\n            \n            logger.info(f\"Iniciando varredura de {len(maquinas)} m√°quinas...\")\n            \n            # Reset dos contadores para esta varredura\n            monitoring_stats[\"successful_checks\"] = 0\n            monitoring_stats[\"failed_checks\"] = 0\n            \n            # Executa verifica√ß√µes em paralelo\n            with ThreadPoolExecutor(max_workers=MAX_WORKERS) as pool:\n                futures = [pool.submit(checar_um_host, m) for m in maquinas]\n                \n                # Processa resultados conforme completam\n                for future in as_completed(futures):\n                    try:\n                        result = future.result(timeout=5)\n                        if result is None:\n                            monitoring_stats[\"failed_checks\"] += 1\n                    except Exception as e:\n                        logger.error(f\"Erro no worker: {e}\")\n                        monitoring_stats[\"failed_checks\"] += 1\n            \n            # Calcula tempo da varredura\n            scan_duration = time.perf_counter() - start_time\n            monitoring_stats[\"last_scan_duration\"] = round(scan_duration, 2) if scan_duration is not None else 0\n            monitoring_stats[\"total_scans\"] += 1\n            \n            logger.info(\n                f\"Varredura conclu√≠da em {scan_duration:.2f}s. \"\n                f\"Sucessos: {monitoring_stats['successful_checks']}, \"\n                f\"Falhas: {monitoring_stats['failed_checks']}\"\n            )\n            \n            time.sleep(CHECK_INTERVAL)\n            \n        except Exception as e:\n            logger.error(f\"Erro cr√≠tico no worker loop: {e}\")\n            time.sleep(CHECK_INTERVAL)\n\n# ----------------- Rotas Flask -----------------\n\n@app.route(\"/\")\ndef home():\n    return render_template(\"index.html\")\n\n@app.route(\"/status\")\ndef status():\n    items = list(status_cache.values())\n    items.sort(key=lambda x: (x[\"status\"] != \"Online\", x[\"name\"].lower()))\n    resp = []\n    for it in items:\n        resp.append({\n            \"name\": it[\"name\"],\n            \"ip\": it[\"ip\"],  # IP atual resolvido automaticamente\n            \"status\": it[\"status\"],\n            \"time_last_checked\": formatar_data_br(it[\"last_checked\"]) if it[\"last_checked\"] else None,\n            \"latency_ms\": it[\"latency_ms\"],\n            \"reason\": it.get(\"reason\"),  # Motivo se offline (ex: DNS_FAIL)\n            \"ip_changed\": it.get(\"ip_changed\", False)  # Flag de mudan√ßa de IP\n        })\n    return jsonify(resp)\n\n@app.route(\"/history/<ip>\")\ndef history_by_ip(ip):\n    \"\"\"Rota legada para hist√≥rico por IP\"\"\"\n    with SessionLocal() as db:\n        rows = db.query(HostHistory).filter(HostHistory.ip == ip).order_by(HostHistory.timestamp.desc()).limit(50).all()\n        data = [\n            {\n                \"status\": r.status,\n                \"latency_ms\": r.latency_ms,\n                \"time\": formatar_data_br(r.timestamp)\n            }\n            for r in rows\n        ]\n    return jsonify(data)\n\n@app.route(\"/history/name/<hostname>\")\ndef history_by_name(hostname):\n    \"\"\"Nova rota para hist√≥rico por hostname\"\"\"\n    with SessionLocal() as db:\n        rows = db.query(HostHistory).filter(HostHistory.name == hostname).order_by(HostHistory.timestamp.desc()).limit(50).all()\n        data = [\n            {\n                \"status\": r.status,\n                \"latency_ms\": r.latency_ms,\n                \"time\": formatar_data_br(r.timestamp),\n                \"ip\": r.ip  # Mostra qual IP estava sendo usado na √©poca\n            }\n            for r in rows\n        ]\n    return jsonify(data)\n\n@app.route(\"/stats\")\ndef stats():\n    items = list(status_cache.values())\n    online_count = sum(1 for item in items if item[\"status\"] == \"Online\")\n    offline_count = len(items) - online_count\n    \n    # Calculate average latency for online machines\n    online_latencies = [item[\"latency_ms\"] for item in items if item[\"status\"] == \"Online\" and item[\"latency_ms\"] is not None]\n    avg_latency = round(sum(online_latencies) / len(online_latencies), 2) if online_latencies else 0\n    \n    return jsonify({\n        \"total_machines\": len(items),\n        \"online\": online_count,\n        \"offline\": offline_count,\n        \"avg_latency_ms\": avg_latency,\n        \"last_updated\": formatar_data_br(agora_brasilia()),\n        \"monitoring_stats\": monitoring_stats\n    })\n\n@app.route(\"/export/excel\")\ndef export_excel():\n    items = list(status_cache.values())\n    items.sort(key=lambda x: (x[\"status\"] != \"Online\", x[\"name\"].lower()))\n    \n    # Create DataFrame\n    data = []\n    for item in items:\n        ip_display = item[\"ip\"] if item[\"ip\"] else \"IP n√£o resolvido\"\n        if item.get(\"reason\") == \"DNS_FAIL\":\n            ip_display = \"Falha DNS\"\n            \n        data.append({\n            \"Nome da M√°quina (Hostname)\": item[\"name\"],\n            \"IP Atual\": ip_display,\n            \"Status\": item[\"status\"],\n            \"Lat√™ncia (ms)\": item[\"latency_ms\"] if item[\"latency_ms\"] else \"N/A\",\n            \"√öltima Verifica√ß√£o\": formatar_data_br(item[\"last_checked\"]) if item[\"last_checked\"] else \"Nunca\",\n            \"Observa√ß√µes\": \"IP alterado recentemente\" if item.get(\"ip_changed\") else \"\"\n        })\n    \n    # Create Excel using simpler pandas approach\n    import pandas as pd\n    \n    df = pd.DataFrame(data)\n    \n    # Create Excel in memory\n    buffer = io.BytesIO()\n    \n    # Add header information\n    header_data = []\n    agora = agora_brasilia()\n    header_data.append(['Sistemas Olivium - Relat√≥rio de Status da Rede'])\n    header_data.append([f'Gerado em: {formatar_data_br(agora)}'])\n    header_data.append([''])\n    \n    # Add summary\n    online_count = sum(1 for item in items if item[\"status\"] == \"Online\")\n    offline_count = len(items) - online_count\n    header_data.append([f'Resumo: {len(items)} m√°quinas | {online_count} Online | {offline_count} Offline'])\n    header_data.append([''])\n    \n    # Create header DataFrame\n    header_df = pd.DataFrame(header_data)\n    \n    # Write to Excel with multiple sheets/sections\n    with pd.ExcelWriter(buffer, engine='openpyxl', mode='w') as writer:\n        # Write header\n        header_df.to_excel(writer, sheet_name='Status da Rede', index=False, header=False, startrow=0)\n        \n        # Write main data\n        df.to_excel(writer, sheet_name='Status da Rede', index=False, startrow=6)\n        \n        # Get the workbook and worksheet for styling\n        workbook = writer.book\n        worksheet = writer.sheets['Status da Rede']\n        \n        # Auto-adjust column widths\n        for column in worksheet.columns:\n            max_length = 0\n            column_letter = column[0].column_letter\n            for cell in column:\n                try:\n                    if cell.value:\n                        max_length = max(max_length, len(str(cell.value)))\n                except:\n                    pass\n            adjusted_width = min(max(max_length + 2, 15), 50)\n            worksheet.column_dimensions[column_letter].width = adjusted_width\n    \n    buffer.seek(0)\n    \n    return send_file(\n        buffer,\n        mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n        as_attachment=True,\n        download_name=f'relatorio_rede_{agora.strftime(\"%Y%m%d_%H%M%S\")}.xlsx'\n    )\n\n@app.route(\"/export/pdf\")\ndef export_pdf():\n    items = list(status_cache.values())\n    items.sort(key=lambda x: (x[\"status\"] != \"Online\", x[\"name\"].lower()))\n    \n    # Create PDF in memory\n    buffer = io.BytesIO()\n    doc = SimpleDocTemplate(\n        buffer, \n        pagesize=landscape(A4), \n        rightMargin=40, \n        leftMargin=40, \n        topMargin=60, \n        bottomMargin=60\n    )\n    \n    # Define professional styles\n    styles = getSampleStyleSheet()\n    \n    # Custom styles for modern look\n    title_style = ParagraphStyle(\n        'ModernTitle',\n        parent=styles['Heading1'],\n        fontSize=20,\n        fontName='Helvetica-Bold',\n        spaceAfter=30,\n        alignment=1,  # Center alignment\n        textColor=colors.HexColor('#1e40af')  # Professional blue\n    )\n    \n    subtitle_style = ParagraphStyle(\n        'ModernSubtitle',\n        parent=styles['Normal'],\n        fontSize=12,\n        fontName='Helvetica',\n        spaceAfter=20,\n        alignment=1,\n        textColor=colors.HexColor('#64748b')  # Gray\n    )\n    \n    summary_style = ParagraphStyle(\n        'ModernSummary',\n        parent=styles['Normal'],\n        fontSize=11,\n        fontName='Helvetica',\n        spaceAfter=20,\n        leftIndent=20,\n        textColor=colors.HexColor('#374151')\n    )\n    \n    # Create content\n    story = []\n    \n    # Professional Header\n    agora = agora_brasilia()\n    title = Paragraph('Sistemas Olivium', title_style)\n    subtitle = Paragraph(f'Relat√≥rio de Status da Rede<br/>Gerado em: {formatar_data_br(agora)}', subtitle_style)\n    \n    story.append(title)\n    story.append(subtitle)\n    story.append(Spacer(1, 30))\n    \n    # Summary statistics with modern styling\n    online_count = sum(1 for item in items if item[\"status\"] == \"Online\")\n    offline_count = len(items) - online_count\n    online_latencies = [item[\"latency_ms\"] for item in items if item[\"status\"] == \"Online\" and item[\"latency_ms\"] is not None]\n    avg_latency = round(sum(online_latencies) / len(online_latencies), 2) if online_latencies else 0\n    \n    summary_text = f'''\n    <b>Resumo Executivo:</b><br/>\n    <br/>\n    ‚Ä¢ Total de M√°quinas Monitoradas: <b>{len(items)}</b><br/>\n    ‚Ä¢ M√°quinas Online: <b style=\"color: #059669\">{online_count}</b><br/>\n    ‚Ä¢ M√°quinas Offline: <b style=\"color: #dc2626\">{offline_count}</b><br/>\n    ‚Ä¢ Lat√™ncia M√©dia: <b>{avg_latency}ms</b><br/>\n    ‚Ä¢ Taxa de Disponibilidade: <b>{round((online_count/len(items)*100), 1) if items else 0}%</b><br/>\n    '''\n    summary = Paragraph(summary_text, summary_style)\n    story.append(summary)\n    story.append(Spacer(1, 30))\n    \n    # Professional table with modern styling\n    table_data = [['Nome da M√°quina', 'Endere√ßo IP', 'Status', 'Lat√™ncia (ms)', '√öltima Verifica√ß√£o']]\n    \n    for item in items:\n        table_data.append([\n            str(item[\"name\"] or \"\"),\n            str(item[\"ip\"] or \"\"),\n            str(item[\"status\"] or \"\"),\n            str(item[\"latency_ms\"]) if item[\"latency_ms\"] else \"N/A\",\n            str(formatar_data_br(item[\"last_checked\"])) if item[\"last_checked\"] else \"Nunca\"\n        ])\n    \n    # Create modern table\n    table = Table(table_data, colWidths=[2.2*inch, 1.8*inch, 1*inch, 1*inch, 1.8*inch])\n    table.setStyle(TableStyle([\n        # Modern header styling\n        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#1e40af')),\n        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),\n        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),\n        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),\n        ('FONTSIZE', (0, 0), (-1, 0), 11),\n        ('BOTTOMPADDING', (0, 0), (-1, 0), 15),\n        ('TOPPADDING', (0, 0), (-1, 0), 15),\n        \n        # Modern body styling\n        ('BACKGROUND', (0, 1), (-1, -1), colors.HexColor('#f8fafc')),\n        ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),\n        ('FONTSIZE', (0, 1), (-1, -1), 9),\n        ('GRID', (0, 0), (-1, -1), 0.5, colors.HexColor('#e2e8f0')),\n        ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.HexColor('#f8fafc'), colors.white]),\n        \n        # Column alignment\n        ('ALIGN', (2, 1), (2, -1), 'CENTER'),  # Status column center\n        ('ALIGN', (3, 1), (3, -1), 'CENTER'),  # Latency column center\n        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),\n    ]))\n    \n    # Modern status cell colors\n    for i, item in enumerate(items, 1):\n        if item[\"status\"] == \"Online\":\n            table.setStyle(TableStyle([\n                ('BACKGROUND', (2, i), (2, i), colors.HexColor('#dcfce7')),\n                ('TEXTCOLOR', (2, i), (2, i), colors.HexColor('#166534'))\n            ]))\n        else:\n            table.setStyle(TableStyle([\n                ('BACKGROUND', (2, i), (2, i), colors.HexColor('#fecaca')),\n                ('TEXTCOLOR', (2, i), (2, i), colors.HexColor('#991b1b'))\n            ]))\n    \n    story.append(table)\n    story.append(Spacer(1, 40))\n    \n    # Professional Footer\n    footer_style = ParagraphStyle(\n        'ModernFooter',\n        parent=styles['Normal'],\n        fontSize=9,\n        fontName='Helvetica',\n        alignment=1,\n        textColor=colors.HexColor('#6b7280')\n    )\n    \n    footer_text = f'¬© {agora.year} Sistemas Olivium - Todos os direitos reservados'\n    footer = Paragraph(footer_text, footer_style)\n    story.append(footer)\n    \n    # Build PDF\n    doc.build(story)\n    buffer.seek(0)\n    \n    return send_file(\n        buffer,\n        mimetype='application/pdf',\n        as_attachment=True,\n        download_name=f'relatorio_rede_{agora.strftime(\"%Y%m%d_%H%M%S\")}.pdf'\n    )\n\n@app.route(\"/alerts\")\ndef alerts():\n    offline_machines = []\n    for item in status_cache.values():\n        if item[\"status\"] == \"Offline\" and item[\"last_checked\"]:\n            time_diff = agora_brasilia() - item[\"last_checked\"]\n            if time_diff.total_seconds() > 300:  # Offline for more than 5 minutes\n                offline_machines.append({\n                    \"name\": item[\"name\"],\n                    \"ip\": item[\"ip\"],\n                    \"offline_since\": formatar_data_br(item[\"last_checked\"]),\n                    \"offline_duration\": str(time_diff).split('.')[0]\n                })\n    \n    return jsonify({\n        \"critical_alerts\": len(offline_machines),\n        \"offline_machines\": offline_machines\n    })\n\n@app.route(\"/search\")\ndef search():\n    query = request.args.get('q', '').lower()\n    status_filter = request.args.get('status', '')\n    \n    items = list(status_cache.values())\n    \n    if query:\n        items = [item for item in items if \n                query in item[\"name\"].lower() or \n                query in (item.get(\"ip\") or \"\").lower()]\n    \n    if status_filter:\n        items = [item for item in items if item[\"status\"].lower() == status_filter.lower()]\n    \n    items.sort(key=lambda x: (x[\"status\"] != \"Online\", x[\"name\"].lower()))\n    \n    resp = []\n    for it in items:\n        resp.append({\n            \"name\": it[\"name\"],\n            \"ip\": it[\"ip\"],\n            \"status\": it[\"status\"],\n            \"time_last_checked\": formatar_data_br(it[\"last_checked\"]) if it[\"last_checked\"] else None,\n            \"latency_ms\": it[\"latency_ms\"]\n        })\n    \n    return jsonify(resp)\n\n# ----------------- Inicializa√ß√£o -----------------\n\ndef inicializar_cache():\n    \"\"\"Inicializa o cache com todas as m√°quinas conhecidas - usando hostname como chave\"\"\"\n    logger.info(\"Inicializando cache de m√°quinas...\")\n    for m in carregar_maquinas():\n        hostname = m[\"name\"]\n        status_cache[hostname] = {\n            \"name\": hostname,\n            \"ip\": None,  # Ser√° resolvido dinamicamente\n            \"status\": \"Desconhecido\",\n            \"last_checked\": None,\n            \"latency_ms\": None,\n            \"reason\": None\n        }\n    logger.info(f\"Cache inicializado com {len(status_cache)} m√°quinas\")\n\nif __name__ == \"__main__\":\n    # Configure Flask cache headers for better performance\n    app.config['SEND_FILE_MAX_AGE_DEFAULT'] = 0\n    \n    inicializar_cache()\n    \n    # Start monitoring thread\n    monitoring_thread = threading.Thread(target=worker_loop, daemon=True)\n    monitoring_thread.start()\n    \n    logger.info(\"Sistema de monitoramento iniciado com sucesso!\")\n    \n    # Run Flask server with host 0.0.0.0 for Replit compatibility\n    app.run(host=\"0.0.0.0\", port=5000, debug=False, threaded=True)","size_bytes":27618},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"flask>=3.1.2\",\n    \"openpyxl>=3.1.5\",\n    \"pandas>=2.3.2\",\n    \"pytz>=2025.2\",\n    \"reportlab>=4.4.3\",\n    \"sqlalchemy>=2.0.43\",\n]\n","size_bytes":278},"replit.md":{"content":"# Sistemas Olivium - Network Monitoring System (v2.0)\n\n## Overview\n\nThis is a modernized, professional network monitoring system built for \"Sistemas Olivium\" that provides real-time monitoring of network devices. The application has been completely updated with a modern interface, optimized performance, and professional styling. It performs continuous network scanning using ICMP ping and TCP port checks to monitor device availability across specified IP ranges. The system features a responsive web dashboard with light/dark mode, sticky header, professional footer, and enhanced PDF export capabilities.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## Version 2.0 Modernization Features\n\n### Frontend Modernization\n- **Modern Professional Design**: Complete UI/UX overhaul with clean, professional styling\n- **Light/Dark Mode Toggle**: Manual switching with browser preference persistence\n- **Sticky Header**: \"Sistemas Olivium\" header remains visible during scrolling\n- **Professional Footer**: Dynamic copyright footer adapting to themes\n- **Responsive Design**: Fully responsive across all devices and screen sizes\n- **Status Animations**: Smooth animations for status changes and updates\n- **Enhanced Visual Indicators**: Modern color schemes and gradients\n\n### Backend Optimization\n- **Performance Improvements**: Optimized threading with 32 worker pool\n- **Smart Caching**: Intelligent machine list caching (5-minute intervals)\n- **Error Handling**: Comprehensive error handling and logging\n- **Invalid IP Filtering**: Automatic filtering of malformed IP addresses\n- **Reduced Timeouts**: Optimized ping timeouts (800ms) for better responsiveness\n- **Database Optimization**: Enhanced SQLite configuration with connection pooling\n\n### Enhanced PDF Export\n- **Professional Styling**: Modern PDF design matching dashboard aesthetics\n- **Complete Branding**: Header and footer with \"Sistemas Olivium\" branding\n- **Executive Summary**: Statistics and availability percentages\n- **Modern Color Scheme**: Professional blues and grays\n- **Dynamic Year**: Automatic copyright year updates\n\n## System Architecture\n\n### Backend Architecture\n- **Framework**: Flask web application with SQLAlchemy ORM\n- **Database**: SQLite for storing historical monitoring data\n- **Monitoring Engine**: Multi-threaded network scanning using ThreadPoolExecutor\n- **Data Models**: HostHistory table tracking device status over time\n- **Configuration**: CSV-based machine definitions with configurable network ranges\n\n### Frontend Architecture\n- **UI Framework**: Tailwind CSS for responsive design\n- **JavaScript**: Vanilla JS with Axios for API communication\n- **Real-time Updates**: Periodic AJAX polling to refresh device status\n- **Template Engine**: Jinja2 templates served by Flask\n\n### Network Monitoring Design\n- **Dual Detection**: ICMP ping combined with TCP port scanning (3389, 445, 80)\n- **Concurrency**: Thread pool executor with configurable worker limits (64 max workers)\n- **Scanning Strategy**: Continuous background scanning at 10-second intervals\n- **Cross-platform Support**: Windows and Linux compatible ping implementations\n\n### Data Storage Strategy\n- **SQLite Database**: Single-file database for historical status tracking\n- **In-memory Cache**: Real-time status cache for quick API responses\n- **CSV Configuration**: External machine list management for easy administration\n\n### Error Handling and Performance\n- **Timeout Management**: Configurable ping timeouts (1000ms default)\n- **Latency Tracking**: Response time measurement and storage\n- **Concurrent Processing**: Parallel network checks to minimize scan time\n\n## External Dependencies\n\n### Python Libraries\n- **Flask**: Web framework for API and template serving\n- **SQLAlchemy**: ORM for database operations and schema management\n- **Threading/Concurrent.futures**: Multi-threaded network scanning\n\n### Frontend Dependencies\n- **Tailwind CSS**: CDN-based styling framework for responsive UI\n- **Axios**: HTTP client for API communication\n\n### System Dependencies\n- **Platform-specific ping**: Native OS ping commands for network testing\n- **Socket operations**: TCP port connectivity testing\n- **CSV file handling**: Machine configuration management\n\n### Network Infrastructure\n- **Local Network Access**: Requires network access to target IP ranges\n- **ICMP/TCP Permissions**: May require elevated privileges for network operations","size_bytes":4437},"static/css/tailwind.min.css":{"content":"Not found: /tailwindcss@3.3.0/dist/tailwind.min.css","size_bytes":51}},"version":1}